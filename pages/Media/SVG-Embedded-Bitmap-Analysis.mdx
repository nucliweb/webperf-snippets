# SVG Embedded Bitmap Analysis

Scans all SVG resources on the page ‚Äî both external files and inline `<svg>` elements ‚Äî and flags any that contain embedded bitmap images, reporting name, transfer size, compression encoding, and embedded bitmap details.

**What this snippet detects:**

| Check                                               | Scope                                        |
| --------------------------------------------------- | -------------------------------------------- |
| Inline base64 bitmaps (PNG, JPEG, WebP, AVIF, GIF‚Ä¶) | External SVG files + inline `<svg>` elements |
| External bitmap references via `<image href="">`    | External SVG files + inline `<svg>` elements |
| Transfer size                                       | External SVG files                           |
| Compression encoding (gzip, br, zstd, none)         | External SVG files                           |

### Overview

SVG is a vector format designed to scale without quality loss. Embedding raster (bitmap) images inside an SVG ‚Äî either as base64 data URIs or as external `<image>` references pointing to bitmap files ‚Äî introduces several performance problems:

- **Size bloat**: Base64 encoding inflates a bitmap by approximately 33%. A 100 KB PNG becomes ~133 KB of inline text, and the wrapping SVG cannot be compressed independently.
- **No format negotiation**: The embedded bitmap is served as-is; the browser cannot substitute it with AVIF or WebP based on the `Accept` header.
- **Broken caching**: A change to either the SVG or the bitmap invalidates the other file's cache entry.
- **Blocked parallel loading**: The bitmap cannot be fetched in parallel with the SVG ‚Äî it is hidden inside it and only discovered after the SVG has been downloaded and parsed.

The correct pattern is to reference bitmap assets as separate files:

```html
<!-- ‚ùå Bitmap baked into SVG ‚Äî one large, hard-to-optimize resource -->
<img src="infographic.svg" />
<!-- infographic.svg contains: <image href="data:image/png;base64,iVBORw0K‚Ä¶"> -->

<!-- ‚úÖ Bitmap served independently ‚Äî cached and optimised separately -->
<img src="infographic.svg" />
<!-- infographic.svg references: <image href="chart.avif" width="800" height="600"/> -->
```

### Snippet

```js copy
// SVG Embedded Bitmap Analysis
// https://webperf-snippets.nucliweb.net

(async () => {
  function formatSize(bytes) {
    if (!bytes || bytes === 0) return "‚Äî";
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
  }

  function shortName(url) {
    try {
      const path = new URL(url).pathname;
      const name = path.split("/").pop() || path;
      return name.length > 45 ? "‚Ä¶" + name.slice(-42) : name;
    } catch {
      return url.slice(-45);
    }
  }

  function compressionFromEntry(entry) {
    if (entry.transferSize === 0 && entry.encodedBodySize === 0) return "cached";
    if (entry.encodedBodySize === 0) return "unknown";
    if (entry.encodedBodySize < entry.decodedBodySize) return "compressed";
    return "none";
  }

  function findEmbeddedBitmaps(svgText) {
    const found = [];

    // Inline base64-encoded bitmaps via data URIs
    const dataRe = /data:image\/(png|jpe?g|gif|webp|avif|bmp|tiff?|ico);base64,([A-Za-z0-9+/=]*)/gi;
    let m;
    while ((m = dataRe.exec(svgText)) !== null) {
      found.push({
        kind: "inline",
        format: m[1].replace("jpeg", "jpg"),
        estimatedBytes: Math.floor((m[2].length * 3) / 4),
      });
    }

    // External bitmap URLs referenced via <image href> or xlink:href
    const hrefRe = /(?:xlink:)?href=["']([^"']*\.(?:png|jpe?g|gif|webp|avif|bmp|tiff?|ico))["']/gi;
    while ((m = hrefRe.exec(svgText)) !== null) {
      found.push({
        kind: "external",
        format: m[1].split(".").pop().toLowerCase().replace("jpeg", "jpg"),
        url: m[1],
      });
    }

    return found;
  }

  // ‚îÄ‚îÄ External SVG files (Performance API) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const svgEntries = performance
    .getEntriesByType("resource")
    .filter((e) => e.name.split("?")[0].toLowerCase().endsWith(".svg"));

  const externalResults = await Promise.all(
    svgEntries.map(async (entry) => {
      let compression = compressionFromEntry(entry);
      let bitmaps = [];

      try {
        const res = await fetch(entry.name, { cache: "force-cache" });
        const ce = res.headers.get("content-encoding");
        if (ce) compression = ce; // gzip | br | zstd | deflate
        bitmaps = findEmbeddedBitmaps(await res.text());
      } catch {
        // CORS or network error ‚Äî Performance API data used as fallback
      }

      const transferSize = entry.transferSize > 0 ? entry.transferSize : entry.encodedBodySize;

      return {
        name: shortName(entry.name),
        url: entry.name,
        transferSize,
        compression,
        bitmaps,
      };
    }),
  );

  // ‚îÄ‚îÄ Inline <svg> elements (DOM scan) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const inlineSvgTotal = document.querySelectorAll("svg").length;
  const inlineResults = Array.from(document.querySelectorAll("svg"))
    .map((svg, i) => {
      const html = svg.outerHTML;
      const bitmaps = findEmbeddedBitmaps(html);
      if (!bitmaps.length) return null;
      return {
        name: svg.id ? `#${svg.id}` : `inline-svg[${i + 1}]`,
        transferSize: new Blob([html]).size,
        compression: "N/A",
        bitmaps,
      };
    })
    .filter(Boolean);

  // ‚îÄ‚îÄ Output ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const withBitmaps = [...externalResults.filter((r) => r.bitmaps.length > 0), ...inlineResults];

  if (svgEntries.length === 0 && inlineSvgTotal === 0) {
    console.log("No SVG resources found on this page.");
    return;
  }

  console.group("%cüñºÔ∏è SVG Embedded Bitmap Analysis", "font-weight: bold; font-size: 14px;");

  console.log("");
  console.log("%cSummary", "font-weight: bold;");
  console.log(`   External SVG files    : ${svgEntries.length}`);
  console.log(`   Inline <svg> elements : ${inlineSvgTotal}`);
  console.log(
    `   SVGs with bitmaps     : ${withBitmaps.length}${withBitmaps.length > 0 ? "  ‚ö†Ô∏è" : "  ‚úÖ"}`,
  );

  if (externalResults.length > 0) {
    console.log("");
    console.group(`%cüìã External SVG Resources (${externalResults.length})`, "font-weight: bold;");
    console.table(
      externalResults.map((r) => ({
        name: r.name,
        size: formatSize(r.transferSize),
        compression: r.compression,
        "embedded bitmap": r.bitmaps.length ? `‚ö†Ô∏è ${r.bitmaps.length} found` : "‚úÖ none",
      })),
    );
    console.groupEnd();
  }

  if (withBitmaps.length > 0) {
    console.log("");
    console.group(
      `%c‚ö†Ô∏è SVGs with Embedded Bitmaps (${withBitmaps.length})`,
      "color: #f59e0b; font-weight: bold;",
    );

    withBitmaps.forEach((r) => {
      console.log("");
      console.log(`%cüìÑ ${r.name}`, "font-weight: bold;");
      console.log(`   SVG size    : ${formatSize(r.transferSize)}`);
      console.log(`   Compression : ${r.compression}`);
      r.bitmaps.forEach((b) => {
        if (b.kind === "inline") {
          console.log(`   üñºÔ∏è  inline ${b.format.toUpperCase()} ‚Äî ~${formatSize(b.estimatedBytes)}`);
        } else {
          console.log(`   üîó  external ${b.format.toUpperCase()} ‚Äî ${b.url}`);
        }
      });
    });

    console.groupEnd();

    console.log("");
    console.group("%cüí° Recommendations", "color: #3b82f6; font-weight: bold;");
    console.log("");
    console.log("   Embedded bitmaps inflate SVG size (~33% overhead for base64),");
    console.log("   block format negotiation, and prevent independent caching.");
    console.log("");
    console.log("   ‚úÖ Extract the bitmap and serve it as a separate resource");
    console.log("   ‚úÖ Convert the bitmap to a modern format (AVIF or WebP)");
    console.log('   ‚úÖ Reference it from the SVG: <image href="image.avif" width="‚Ä¶" height="‚Ä¶"/>');
    console.log("   ‚úÖ Both files are then cached and optimised independently");
    console.groupEnd();
  } else {
    console.log("");
    console.log(
      "%c‚úÖ No embedded bitmaps found in SVG resources.",
      "color: #22c55e; font-weight: bold;",
    );
  }

  console.groupEnd();
})();
```

### Understanding the Results

#### Summary

| Field                   | Description                                                                                               |
| ----------------------- | --------------------------------------------------------------------------------------------------------- |
| External SVG files      | Count of SVG resources captured by the Performance API (loaded via `<img>`, `<object>`, CSS, fetch, etc.) |
| Inline `<svg>` elements | Count of `<svg>` elements present in the DOM                                                              |
| SVGs with bitmaps       | SVGs (external or inline) that contain at least one embedded bitmap                                       |

#### External SVG Resources Table

| Column            | Description                                                                                                                                                                            |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`            | Filename extracted from the resource URL                                                                                                                                               |
| `size`            | Bytes transferred over the network (compressed). `‚Äî` means the entry was served from cache with no transfer                                                                            |
| `compression`     | Encoding reported by the `Content-Encoding` response header. Falls back to comparing `encodedBodySize` vs `decodedBodySize` from the Performance API when the header is not accessible |
| `embedded bitmap` | ‚úÖ none ‚Äî no bitmaps detected ¬∑ ‚ö†Ô∏è N found ‚Äî N embedded bitmaps                                                                                                                        |

#### Compression Values

| Value        | Meaning                                                    |
| ------------ | ---------------------------------------------------------- |
| `gzip`       | Compressed with GZIP                                       |
| `br`         | Compressed with Brotli                                     |
| `zstd`       | Compressed with Zstandard                                  |
| `none`       | No content encoding applied                                |
| `compressed` | Compressed (type not accessible ‚Äî CORS restriction)        |
| `cached`     | Resource was served from cache with no transfer size       |
| `N/A`        | Not applicable (inline `<svg>` element ‚Äî no HTTP transfer) |

#### Embedded Bitmap Types

| Icon | Kind       | Description                                                                                                                                                                |
| ---- | ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| üñºÔ∏è   | `inline`   | Base64-encoded bitmap embedded directly as a `data:image/‚Ä¶;base64,` URI. The reported size is an estimate derived from the base64 string length                            |
| üîó   | `external` | Bitmap file referenced via `href` or `xlink:href` on an `<image>` element. The bitmap is a separate HTTP request, but it is still discovered only after the SVG has loaded |

> **CORS note**: The snippet fetches each SVG with `cache: "force-cache"` to read headers and content without triggering new network requests. Cross-origin SVGs without CORS headers cannot be read ‚Äî in that case the snippet falls back to Performance API timing data for size and compression, and bitmap detection is skipped for that resource.

### Further Reading

- [SVG `<image>` element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image) | MDN
- [Data URLs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) | MDN
- [SVGOMG](https://jakearchibald.github.io/svgomg/) | jakearchibald.github.io
- [SVGO](https://github.com/svg/svgo) | GitHub
- [Image Element Audit](/Media/Image-Element-Audit) | webperf-snippets
